ğŸ§ª Task 1: Basic Hello World Compilation Using RISC-V Toolchain
ğŸ¯ Objective
The goal is to verify that your RISC-V cross compiler works by compiling a simple C program (hello.c) into an object file (hello.o) and checking that the toolchain runs successfully without errors.

ğŸ“œ C Code Used â€” hello.c
c
Copy
Edit
#include <stdio.h>

int main() {
    printf("Hello, VSD!\n");
    return 0;
}
ğŸ“ Save it in:

bash
Copy
Edit
~/Desktop/vsdflow/task1/hello.c
âš™ï¸ Working Commands (Tested and Successful)
bash
Copy
Edit
cd ~/Desktop/vsdflow/task1

# Compile hello.c to RISC-V object code
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o

# Check that object file is created
ls -lh hello.o
You should see:

bash
Copy
Edit
-rw-r--r-- 1 amritha-s amritha-s 1.2K ... hello.o
âœ… This confirms successful compilation into RISC-V object code.

ğŸ“‹ Task Checklist Table
Task #	Description	Done?
1.1	Write a simple C program (hello.c)	âœ…
1.2	Use riscv32-unknown-elf-gcc to compile it	âœ…
1.3	Verify hello.o is generated	âœ…
1.4	Capture a screenshot of output in terminal	ğŸ”²

ğŸ”² = You fill this in by taking and adding the screenshot

ğŸ–¼ï¸ Output Screenshot
ğŸ“¸ Paste your screenshot below this line showing the terminal output after running the commands:

(Example: object file listing or success message after compiling)

ğŸ“˜ Explanation
In embedded systems and compiler verification, it's important to start small and check that:

âœ… The compiler runs correctly

âœ… The input source compiles to an object file

âœ… The object file contains valid RISC-V machine code

âš™ï¸ Task 2: Build Full RISC-V Executable from Hello World
ğŸ¯ Objective
Take the compiled object file from hello.c and link it into an actual RISC-V executable (hello.elf) using riscv32-unknown-elf-gcc. This tests the ability of the toolchain to link and generate a complete ELF binary, preparing you for future steps like custom linker scripts or running on simulators.

ğŸ“ File Structure Before Starting
bash
Copy
Edit
~/Desktop/vsdflow/task2/
â”œâ”€â”€ hello.c
âœ… If hello.c doesnâ€™t exist, copy it from Task 1:

bash
Copy
Edit
cp ~/Desktop/vsdflow/task1/hello.c ~/Desktop/vsdflow/task2/
ğŸ’» Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task2

# Step 1: Compile C code into object file
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o

# Step 2: Link object file into full ELF executable
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc hello.o -o hello.elf

# Step 3: Check that ELF file is created
ls -lh hello.elf
ğŸ“Œ Output of the final ls should show:

bash
Copy
Edit
-rwxr-xr-x 1 amritha-s amritha-s 7.5K ... hello.elf
ğŸ“‹ Task Checklist Table
Task #	Description	Done?
2.1	Copy or reuse hello.c from Task 1	âœ…
2.2	Compile to object file: hello.o	âœ…
2.3	Link to ELF executable: hello.elf	âœ…
2.4	Confirm ELF file is created via ls -lh hello.elf	âœ…
2.5	Capture screenshot of ELF generation in terminal	ğŸ”²

ğŸ–¼ï¸ Output Screenshot
ğŸ“¸ Paste your terminal screenshot here showing the ELF file (hello.elf) successfully created.

ğŸ“˜ Explanation
Linking is the second key step in the embedded toolchain pipeline:

hello.c is first compiled into hello.o (raw code + symbol info).

Then hello.o is linked to generate hello.elf â€” a proper executable with:

Program headers

Sections like .text, .data, .bss

Entry point (_start or main)

hello.elf can now be inspected, simulated, or flashed (later).

âš™ï¸ Task 3: Disassemble and Inspect the RISC-V ELF Executable
ğŸ¯ Objective
Disassemble the hello.elf binary using objdump to verify what machine instructions were generated by the RISC-V toolchain for your C code. This step proves that the compiler is working and that you're able to interpret generated RISC-V assembly.

ğŸ“ File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task3/
â”œâ”€â”€ hello.c         # (Copied from Task 1 or 2)
â”œâ”€â”€ hello.o         # (Compiled)
â”œâ”€â”€ hello.elf       # (Linked ELF file)
If you don't have these yet:

bash
Copy
Edit
cp ~/Desktop/vsdflow/task2/* ~/Desktop/vsdflow/task3/
ğŸ’» Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task3

# Step 1: Compile C code if needed
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o

# Step 2: Link to generate ELF
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc hello.o -o hello.elf

# Step 3: Disassemble the ELF to view RISC-V instructions
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d hello.elf | less
ğŸ“Œ Press q to quit the disassembly viewer (less).

ğŸ“‹ Task Checklist Table
Task #	Description	Done?
3.1	Ensure hello.elf is available from previous task	âœ…
3.2	Use objdump to disassemble the ELF	âœ…
3.3	Confirm function labels and assembly instructions appear	âœ…
3.4	Take a screenshot of the disassembled output in terminal	ğŸ”²

ğŸ–¼ï¸ Output Screenshot
ğŸ“¸ Paste screenshot showing assembly output â€” particularly the disassembly of main function.

Expected disassembly includes lines like:

asm
Copy
Edit
00000074 <main>:
  ...
  00000078:   00000513    li a0,0
  0000007c:   00008067    ret
ğŸ“˜ Explanation
This task validates:

âœ… That your compiled ELF contains valid RISC-V machine code

âœ… That the toolchain correctly emits labels like main, _start

âœ… That objdump -d allows you to inspect what instructions were generated

This is crucial for debugging low-level behavior and ensuring what your source code compiles into at the ISA level.

âš™ï¸ Task 5: Compile and Link Assembly Code with RISC-V Toolchain
ğŸ¯ Objective
Compile a standalone RISC-V assembly file (start.s) and link it into an ELF file using the RISC-V toolchain. This verifies that the assembler and linker stages work independently of C code.

ğŸ“ File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task5/
â”œâ”€â”€ start.s         # Simple RISC-V assembly file
â”œâ”€â”€ start.o         # Assembled object file
â”œâ”€â”€ start.elf       # Final linked ELF file
ğŸ’» Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task5

# Step 1: Create your assembly file (if not yet done)
cat << 'EOF' > start.s
.section .text
.global _start
_start:
    li a0, 10
    li a1, 20
    add a2, a0, a1
1:  j 1b
EOF

# Step 2: Assemble to object file
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-as start.s -o start.o

# Step 3: Link into an ELF
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld start.o -o start.elf

# Step 4: Verify ELF sections
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d start.elf | less
ğŸ“‹ Task Checklist Table
Task #	Description	Done?
5.1	Create standalone start.s assembly file	âœ…
5.2	Assemble to start.o using as	âœ…
5.3	Link to start.elf using ld	âœ…
5.4	Verify machine instructions via objdump	âœ…
5.5	Screenshot of assembly + ELF disassembly	ğŸ”²

ğŸ–¼ï¸ Output Screenshot
ğŸ“¸ Take a screenshot showing successful assembly, linking, and output from:

bash
Copy
Edit
riscv32-unknown-elf-objdump -d start.elf
ğŸ“˜ Explanation
This task proves:

âœ… You can write, assemble, and link raw RISC-V assembly

âœ… The ELF file structure is correct even without C runtime

âœ… Understanding of label _start, registers, and loops

âš™ï¸ Task 6: Combine Assembly and C Code
ğŸ¯ Objective
Link an assembly startup file (start.s) with a simple C program (hello.c) to form a working ELF, mimicking how embedded programs boot from assembly and jump into C.

ğŸ“ File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task6/
â”œâ”€â”€ start.s         # Assembly file with _start
â”œâ”€â”€ hello.c         # Simple C function (no main needed)
â”œâ”€â”€ start.o         # Object from start.s
â”œâ”€â”€ hello.o         # Object from hello.c
â”œâ”€â”€ start.elf       # Final linked ELF
ğŸ’» Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task6

# Step 1: Write hello.c
cat << 'EOF' > hello.c
int my_function() { return 42; }
EOF

# Step 2: Reuse or write start.s
cat << 'EOF' > start.s
.section .text
.global _start
_start:
    call my_function
1:  j 1b
EOF

# Step 3: Compile both
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-as start.s -o start.o

# Step 4: Link them
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld start.o hello.o -o start.elf

# Step 5: Disassemble to confirm function linkage
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d start.elf | less
ğŸ“‹ Task Checklist Table
Task #	Description	Done?
6.1	Create C function (hello.c)	âœ…
6.2	Call C function from _start in assembly	âœ…
6.3	Compile both .c and .s to .o files	âœ…
6.4	Link them to start.elf	âœ…
6.5	Disassemble to confirm call my_function	âœ…
6.6	Screenshot with function call disassembly	ğŸ”²

ğŸ–¼ï¸ Output Screenshot
Show a disassembly with the call my_function inside _start, plus the function itself.

ğŸ“˜ Explanation
Youâ€™ve built an ELF where:

ğŸ§  Assembly handles boot (simulating reset vector)

ğŸ§  C logic handles logic (like embedded apps do)

ğŸ§  You verified the function call path manually via disassembly

âš™ï¸ Task 7: Inspect and Understand Symbols
ğŸ¯ Objective
Use nm and objdump to explore symbols in the ELF â€” both from C and Assembly â€” and understand where functions and data reside.

ğŸ“ File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task7/
â”œâ”€â”€ hello.c         # Your C code from Task 6
â”œâ”€â”€ start.s         # Assembly file with _start
â”œâ”€â”€ *.o             # Object files
â”œâ”€â”€ start.elf       # Final executable
ğŸ’» Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task7

# Copy working files from Task 6
cp ~/Desktop/vsdflow/task6/* .

# Rebuild for clean state
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-as start.s -o start.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld start.o hello.o -o start.elf

# View symbols
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-nm start.elf
Expected output:

bash
Copy
Edit
00000000 T _start
00000014 T my_function
ğŸ“‹ Task Checklist Table
Task #	Description	Done?
7.1	Use nm to inspect function symbols	âœ…
7.2	Confirm _start and my_function locations	âœ…
7.3	Explain sections (T = text, D = data, B = bss)	âœ…
7.4	Screenshot of nm output	ğŸ”²

ğŸ–¼ï¸ Output Screenshot
Take screenshot of nm start.elf output showing symbols:

r
Copy
Edit
00000000 T _start
00000014 T my_function
ğŸ“˜ Explanation
You now understand:

âœ… What symbols are in an ELF file

âœ… How to locate your functions (_start, main, etc.)

âœ… How code gets organized into sections (.text, .data, .bss)

âœ… TASK 8 â€” Exploring Compiler Optimizations (O0 vs O1 vs O2 vs O3)
âœ… Objective:
Compare performance and size differences of the compiled RISC-V code under different GCC optimization flags (-O0, -O1, -O2, -O3) using a loop delay program.

ğŸ“ File Setup:
bash
Copy
Edit
cd ~/Desktop/vsdflow && mkdir -p task8 && cd task8
ğŸ’» Code: loop_opt.c
c
Copy
Edit
void delay_loop() {
    volatile int i;
    for (i = 0; i < 10000; i++) {
        // Do nothing
    }
}

int main() {
    delay_loop();
    return 0;
}
ğŸ’» Build Script: build_all_opts.sh
bash
Copy
Edit
#!/bin/bash
RISCV=/home/amritha-s/vsdflow/riscv/opt/riscv/bin

for opt in 0 1 2 3; do
    echo "=== Building with -O$opt ==="
    $RISCV/riscv32-unknown-elf-gcc -O$opt -o loop_O$opt.elf loop_opt.c
    $RISCV/riscv32-unknown-elf-size loop_O$opt.elf
    echo ""
done
Make executable and run:

bash
Copy
Edit
chmod +x build_all_opts.sh
./build_all_opts.sh
ğŸ“‹ Explanation:
This builds the same file with four optimization levels:

-O0: No optimization (baseline)

-O1: Basic optimization

-O2: Further optimization including loop unrolling

-O3: Aggressive optimization (may inline)

Check how each optimization affects binary size and speed by comparing ELF file size using riscv32-unknown-elf-size.

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Screenshot of terminal running ./build_all_opts.sh and showing sizes

ğŸ“Š Summary Table:
Flag	Optimizes For	Binary Size	Speed (Subjective)
-O0	Debugging, no opt	Largest	Slowest
-O1	Basic perf	Smaller	Faster
-O2	Balance perf/size	Smaller	Fast
-O3	Max speed	May be same	Fastest

âœ… TASK 9 â€” Using objdump to Understand Optimization
âœ… Objective:
Disassemble .elf files to compare assembly instructions generated at each optimization level.

ğŸ’» Disassemble with objdump
bash
Copy
Edit
for opt in 0 1 2 3; do
    echo "=== Disassembly with -O$opt ==="
    /home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d loop_O$opt.elf > disasm_O$opt.txt
done
Then inspect each disasm_Ox.txt to compare loop code and check if:

Loop is optimized

Function is inlined

NOPs removed

ğŸ“‹ Explanation:
Using objdump -d, you decode machine code into human-readable assembly to understand compiler behavior.

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Screenshot of one of the disassembled .txt files or diff comparison

âœ… TASK 10 â€” Compiling with Debug Info and Analyzing Symbols
âœ… Objective:
Use -g flag to include debug info and explore .symtab.

ğŸ’» Compile with Debug Info
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -O2 -g -o debug.elf loop_opt.c
ğŸ’» View Symbols with nm
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-nm debug.elf
ğŸ“‹ Explanation:
With -g, symbols like main, delay_loop remain visible. Use nm to confirm variable locations, function scope, and linkage.

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Screenshot of output from nm debug.elf
### âœ… TASK 11 â€” Custom Linker Script (minimal.ld)

#### âœ… Objective:
Write a minimal custom linker script to control memory layout. Specifically:
- Place `.text` in Flash memory (0x00000000)
- Place `.data` and `.bss` in SRAM (0x10000000)
- Define `_stack_top` symbol at end of SRAM

---

#### ğŸ“ File Setup:
```bash
cd ~/Desktop/vsdflow/task11
```
Code: minimal.ld
ld
Copy
Edit
ENTRY(_start)

MEMORY {
  FLASH (rx)  : ORIGIN = 0x00000000, LENGTH = 256K
  SRAM  (rwx) : ORIGIN = 0x10000000, LENGTH = 64K
}

SECTIONS {
  .text : {
    *(.text.start)
    *(.text)
    *(.rodata)
  } > FLASH

  .data : {
    _data_start = .;
    *(.data)
    _data_end = .;
  } > SRAM

  .bss : {
    _bss_start = .;
    *(.bss)
    _bss_end = .;
  } > SRAM

  _stack_top = ORIGIN(SRAM) + LENGTH(SRAM);
}
ğŸ’» Supporting Files:
test_linker.c

c
Copy
Edit
#include <stdint.h>
uint32_t global_var = 0x12345678;
uint32_t bss_var;
void test_function(void) {
    global_var = 0xABCDEF00;
    bss_var = 0x11111111;
}
void main(void) {
    test_function();
    while (1) {}
}
start.s

asm
Copy
Edit
.section .text.start
.global _start
_start:
  lui sp, %hi(_stack_top)
  addi sp, sp, %lo(_stack_top)
  call main
1: j 1b
.size _start, . - _start
ğŸ’» Build All Files in One Go:
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c start.s -o start.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c test_linker.c -o test_linker.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld -T minimal.ld start.o test_linker.o -o test_linker.elf
ğŸ’» Inspect ELF Output:
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -h test_linker.elf
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-nm test_linker.elf
ğŸ“‹ Explanation:
.text should start at 0x00000000 (Flash)

.data and .bss go into SRAM

_start entry at 0x00000000

ELF confirms correct memory placement

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Screenshot of objdump -h and nm outputs

âœ… TASK 12 â€” LED Blinking with Linker + Disassembly
âœ… Objective:
Blink an LED using memory-mapped I/O and compile it with a custom linker script.

ğŸ“ File Setup:
bash
Copy
Edit
cd ~/Desktop/vsdflow && rm -rf task12 && mkdir task12 && cd task12
ğŸ’» Code: task12_led_blink.c
c
Copy
Edit
#include <stdint.h>
#define GPIO_BASE 0x10012000
#define GPIO_OUTPUT_REG (*(volatile uint32_t *)(GPIO_BASE + 0x00))
#define GPIO_DIRECTION_REG (*(volatile uint32_t *)(GPIO_BASE + 0x04))

void delay(volatile int count) {
    while(count--) { asm volatile("nop"); }
}

int main(void) {
    GPIO_DIRECTION_REG |= 0x1;
    while (1) {
        GPIO_OUTPUT_REG ^= 0x1;
        delay(100000);
    }
    return 0;
}
led_start.s

asm
Copy
Edit
.section .text.start
.global _start
_start:
    lui sp, %hi(_stack_top)
    addi sp, sp, %lo(_stack_top)
    call main
1:  j 1b
led_blink.ld

ld
Copy
Edit
ENTRY(_start)

MEMORY {
  FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 256K
  SRAM  (rwx): ORIGIN = 0x10000000, LENGTH = 64K
}

SECTIONS {
  .text : {
    *(.text.start)
    *(.text)
    *(.rodata*)
  } > FLASH

  .data : {
    _data_start = .;
    *(.data)
    _data_end = .;
  } > SRAM

  .bss : {
    _bss_start = .;
    *(.bss)
    _bss_end = .;
  } > SRAM

  _stack_top = ORIGIN(SRAM) + LENGTH(SRAM);
}
ğŸ’» Build Script: build_led_blink.sh
bash
Copy
Edit
#!/bin/bash
RISCV=/home/amritha-s/vsdflow/riscv/opt/riscv/bin

echo "=== Building LED Blink ==="
$RISCV/riscv32-unknown-elf-gcc -c led_start.s -o led_start.o
$RISCV/riscv32-unknown-elf-gcc -c task12_led_blink.c -o task12_led_blink.o
$RISCV/riscv32-unknown-elf-ld -T led_blink.ld led_start.o task12_led_blink.o -o task12_led_blink.elf

echo "=== ELF Sections ==="
$RISCV/riscv32-unknown-elf-objdump -h task12_led_blink.elf

echo "=== Disassembly ==="
$RISCV/riscv32-unknown-elf-objdump -d task12_led_blink.elf | less
bash
Copy
Edit
chmod +x build_led_blink.sh
./build_led_blink.sh
ğŸ“‹ Explanation:
GPIO is toggled using memory-mapped I/O

Delay uses software nop loop

Custom linker places code and variables properly

Objdump output confirms working ELF

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Screenshot of blinking logic disassembly or ELF sections
### âœ… TASK 13 â€” Interrupt Primer (MTIP Handler)

#### âœ… Objective:
Enable the machine-timer interrupt (MTIP) and write a simple handler in C/assembly.

---

#### ğŸ› ï¸ Files & Line-up

`timer_interrupt.c`
```c
#define UART_TX 0x10000000
#define UART_READY 0x10000005
#define MTIME 0x0200BFF8
#define MTIMECMP 0x02004000
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

void uart_putc(char c) {
    volatile char* tx = (volatile char*)UART_TX;
    volatile char* rd = (volatile char*)UART_READY;
    while (!(*rd & (1 << 5)));
    *tx = c;
}

void uart_puts(const char* s) {
    while (*s) uart_putc(*s++);
}

void timer_handler(void) {
    uart_puts("MTIP\n");
    volatile uint64_t* mtime = (volatile uint64_t*)MTIME;
    volatile uint64_t* mtimecmp = (volatile uint64_t*)MTIMECMP;
    *mtimecmp = *mtime + 1000000;
}

void enable_timer_interrupt(void) {
    volatile uint64_t* mtime = (volatile uint64_t*)MTIME;
    volatile uint64_t* mtimecmp = (volatile uint64_t*)MTIMECMP;
    *mtimecmp = *mtime + 1000000;
    asm volatile("li t0, 0x80");
    asm volatile("csrs mie, t0");
    asm volatile("csrs mstatus, 0x8");
}

int main() {
    uart_putc('A');
    enable_timer_interrupt();
    uart_puts("Timer enabled\n");
    while (1) {
        uart_putc('.');
        for (volatile int i = 0; i < 100000; i++);
    }
    return 0;
}
```
trap_handler.s

asm
Copy
Edit
.section .text
.global trap_handler
.align 4
trap_handler:
    addi sp, sp, -64
    sw ra, 0(sp)
    sw t0, 4(sp)
    sw t1, 8(sp)
    csrr t0, mcause
    li t1, 0x80000007
    bne t0, t1, skip
    jal timer_handler
skip:
    lw ra, 0(sp)
    lw t0, 4(sp)
    lw t1, 8(sp)
    addi sp, sp, 64
    mret
startup13.s

asm
Copy
Edit
.section .text.start
.global _start
_start:
    la sp, _stack_top
    li t0, 0x10000005
    li t1, 0x20
wait_uart:
    lb t2, 0(t0)
    and t2, t2, t1
    beq t2, zero, wait_uart
    li t0, 0x10000000
    li t1, 'S'
    sb t1, 0(t0)
    la t0, trap_handler
    csrw mtvec, t0
    jal main
    j .
.section .bss
.align 4
.space 1024
_stack_top:
linker13.ld

ld
Copy
Edit
OUTPUT_ARCH(riscv)
ENTRY(_start)
MEMORY {
  FLASH (rx) : ORIGIN = 0x80000000, LENGTH = 16M
  RAM   (rw) : ORIGIN = 0x81000000, LENGTH = 16M
}
SECTIONS {
  .text : { *(.text.start) *(.text*) } > FLASH
  .rodata : ALIGN(4) { *(.rodata*) } > FLASH
  .data : ALIGN(4) { *(.data*) } > RAM AT > FLASH
  .bss   : ALIGN(4) { *(.bss*) } > RAM
  _end = .;
}
ğŸ’» Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -g -O0 -march=rv32im -mabi=ilp32 -nostdlib \
  -T linker13.ld \
  -o timer.elf \
  timer_interrupt.c startup13.s trap_handler.s

qemu-system-riscv32 -nographic -machine virt -bios none -kernel timer.elf
ğŸ“‹ Expected Output:
nginx
Copy
Edit
SATimer enabled
........MTIP
MTIP
MTIP
MTIP
ğŸ Issues Faced:
Incorrect CSR writes to mie and mstatus: fixed ordering.

Confirmed MTIP fires correctly.

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Screenshot of UART output showing periodic "MTIP"

âœ… TASK 14 â€” RV32IMAC vs RV32IMC (â€œAâ€ Extension)
âœ… Objective:
Compare RV32IMC vs RV32IMAC, focusing on atomic instructions.

ğŸ› ï¸ Summary Table
Feature	RV32IMC	RV32IMAC
I (Base Int)	âœ…	âœ…
M (Mul/Div)	âœ…	âœ…
C (Compressed)	âœ…	âœ…
A (Atomic)	âŒ	âœ…

ğŸ”¸ Atomic Instruction Set
Instruction	Meaning	Use Case
lr.w	Load-Reserved	Begin RMW atomic op
sc.w	Store-Conditional	Complete atomic store
amoadd.w	Atomic Add	Atomic update of counter
amoswap.w	Atomic Swap	Exchange value atomically
amoor.w	Atomic OR	Set flags atomically
amoand.w	Atomic AND	Clear flags atomically
amomin.w	Atomic Min	Resource arbitration
amomax.w	Atomic Max	Tracking max safely

âœ… Status: Completed
ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Diagram/table comparing RV32IMC vs RV32IMAC and listing atomic instructions

âœ… TASK 15 â€” Atomic Test Program (lr.w/sc.w Mutex)
âœ… Objective:
Implement a spin-lock mutex using lr.w / sc.w, simulate two â€œthreadsâ€.

ğŸ› ï¸ Code Files
task15.c (Full code in previous message)

Linker15.ld (As above)

startup15.s (As above)

ğŸ’» Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -g -O0 -march=rv32imac -mabi=ilp32 -nostdlib \
  -T Linker15.ld \
  -o task15.elf \
  task15.c startup15.s

qemu-system-riscv32 -nographic -machine virt -bios none -kernel task15.elf
ğŸ’¬ Expected Output:
makefile
Copy
Edit
SAStarting threads
T1: Enter critical section
T1: Counter = 1
...
Done
........
ğŸ Issues Faced:
Initial infinite loop due to improper sc.w retry logic.

Fixed by ensuring sc.w return checked, with correct CVS stubs.

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Snapshot showing interleaved thread output and mutex working

âœ… TASK 16 â€” Newlib printf on Bare-Metal
âœ… Objective:
Retarget _write() for printf() to memory-mapped UART in bare-metal environment.

ğŸ› ï¸ Code Files
Task16.c (Includes _write, _sbrk, etc.)

startup16.s, linker16.ld (As above)

ğŸ’» Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 \
  -c startup16.s task16.c

riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 -nostartfiles \
  -T linker16.ld \
  -o task16.elf startup16.o task16.o

qemu-system-riscv32 -nographic -machine virt -bios none -kernel task16.elf
ğŸ’¬ Expected Output:
yaml
Copy
Edit
SAHello, RISC-V! Counter: 42
........
ğŸ Issues Faced:
printf silent until adding _fstat(), _isatty(), _sbrk().

Needed correct errno handling and heap limit.

ğŸ“¸ Screenshot Placeholder:
ğŸ“¸ Console showing "Hello, RISCâ€‘V! Counter: 42" and running dots

âœ… TASK 17 â€” Endianness & Struct Packing Check
âœ… Objective:
Verify RV32 endianness with union trick and print byte order via UART.

ğŸ› ï¸ Code Files
task17.c, startup17.s, linker17.ld (As above)

ğŸ’» Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -c task17.c -march=rv32imac -mabi=ilp32 -Os
riscv32-unknown-elf-gcc -c startup17.s -march=rv32imac -mabi=ilp32
riscv32-unknown-elf-gcc startup17.o task17.o -march=rv32imac -mabi=ilp32 \
  -nostartfiles -T linker17.ld -o task17.elf

qemu-system-riscv32 -nographic -machine virt -bios none -kernel task17.elf
ğŸ’¬ Expected Output:
yaml
Copy
Edit
Bareâ€‘metal RISCâ€‘V Application
Value of x: 43
Verifying Byte Ordering (Endianness):
Value stored: 0x01020304
Bytes in memory:
Byte 0: 0x04
...
This system is Littleâ€‘Endian.
ğŸ Issues Faced:
Required explicit \n to make output readable.

Used volatile to ensure union not optimized away.

ğŸ“¸ Screenshot Placeholder:
