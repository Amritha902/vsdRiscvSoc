🧪 Task 1: Basic Hello World Compilation Using RISC-V Toolchain
🎯 Objective
The goal is to verify that your RISC-V cross compiler works by compiling a simple C program (hello.c) into an object file (hello.o) and checking that the toolchain runs successfully without errors.

📜 C Code Used — hello.c
c
Copy
Edit
#include <stdio.h>

int main() {
    printf("Hello, VSD!\n");
    return 0;
}
📁 Save it in:

bash
Copy
Edit
~/Desktop/vsdflow/task1/hello.c
⚙️ Working Commands (Tested and Successful)
bash
Copy
Edit
cd ~/Desktop/vsdflow/task1

# Compile hello.c to RISC-V object code
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o

# Check that object file is created
ls -lh hello.o
You should see:

bash
Copy
Edit
-rw-r--r-- 1 amritha-s amritha-s 1.2K ... hello.o
✅ This confirms successful compilation into RISC-V object code.

📋 Task Checklist Table
Task #	Description	Done?
1.1	Write a simple C program (hello.c)	✅
1.2	Use riscv32-unknown-elf-gcc to compile it	✅
1.3	Verify hello.o is generated	✅
1.4	Capture a screenshot of output in terminal	🔲

🔲 = You fill this in by taking and adding the screenshot

🖼️ Output Screenshot
📸 Paste your screenshot below this line showing the terminal output after running the commands:

(Example: object file listing or success message after compiling)

📘 Explanation
In embedded systems and compiler verification, it's important to start small and check that:

✅ The compiler runs correctly

✅ The input source compiles to an object file

✅ The object file contains valid RISC-V machine code

⚙️ Task 2: Build Full RISC-V Executable from Hello World
🎯 Objective
Take the compiled object file from hello.c and link it into an actual RISC-V executable (hello.elf) using riscv32-unknown-elf-gcc. This tests the ability of the toolchain to link and generate a complete ELF binary, preparing you for future steps like custom linker scripts or running on simulators.

📁 File Structure Before Starting
bash
Copy
Edit
~/Desktop/vsdflow/task2/
├── hello.c
✅ If hello.c doesn’t exist, copy it from Task 1:

bash
Copy
Edit
cp ~/Desktop/vsdflow/task1/hello.c ~/Desktop/vsdflow/task2/
💻 Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task2

# Step 1: Compile C code into object file
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o

# Step 2: Link object file into full ELF executable
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc hello.o -o hello.elf

# Step 3: Check that ELF file is created
ls -lh hello.elf
📌 Output of the final ls should show:

bash
Copy
Edit
-rwxr-xr-x 1 amritha-s amritha-s 7.5K ... hello.elf
📋 Task Checklist Table
Task #	Description	Done?
2.1	Copy or reuse hello.c from Task 1	✅
2.2	Compile to object file: hello.o	✅
2.3	Link to ELF executable: hello.elf	✅
2.4	Confirm ELF file is created via ls -lh hello.elf	✅
2.5	Capture screenshot of ELF generation in terminal	🔲

🖼️ Output Screenshot
📸 Paste your terminal screenshot here showing the ELF file (hello.elf) successfully created.

📘 Explanation
Linking is the second key step in the embedded toolchain pipeline:

hello.c is first compiled into hello.o (raw code + symbol info).

Then hello.o is linked to generate hello.elf — a proper executable with:

Program headers

Sections like .text, .data, .bss

Entry point (_start or main)

hello.elf can now be inspected, simulated, or flashed (later).

⚙️ Task 3: Disassemble and Inspect the RISC-V ELF Executable
🎯 Objective
Disassemble the hello.elf binary using objdump to verify what machine instructions were generated by the RISC-V toolchain for your C code. This step proves that the compiler is working and that you're able to interpret generated RISC-V assembly.

📁 File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task3/
├── hello.c         # (Copied from Task 1 or 2)
├── hello.o         # (Compiled)
├── hello.elf       # (Linked ELF file)
If you don't have these yet:

bash
Copy
Edit
cp ~/Desktop/vsdflow/task2/* ~/Desktop/vsdflow/task3/
💻 Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task3

# Step 1: Compile C code if needed
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o

# Step 2: Link to generate ELF
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc hello.o -o hello.elf

# Step 3: Disassemble the ELF to view RISC-V instructions
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d hello.elf | less
📌 Press q to quit the disassembly viewer (less).

📋 Task Checklist Table
Task #	Description	Done?
3.1	Ensure hello.elf is available from previous task	✅
3.2	Use objdump to disassemble the ELF	✅
3.3	Confirm function labels and assembly instructions appear	✅
3.4	Take a screenshot of the disassembled output in terminal	🔲

🖼️ Output Screenshot
📸 Paste screenshot showing assembly output — particularly the disassembly of main function.

Expected disassembly includes lines like:

asm
Copy
Edit
00000074 <main>:
  ...
  00000078:   00000513    li a0,0
  0000007c:   00008067    ret
📘 Explanation
This task validates:

✅ That your compiled ELF contains valid RISC-V machine code

✅ That the toolchain correctly emits labels like main, _start

✅ That objdump -d allows you to inspect what instructions were generated

This is crucial for debugging low-level behavior and ensuring what your source code compiles into at the ISA level.

⚙️ Task 5: Compile and Link Assembly Code with RISC-V Toolchain
🎯 Objective
Compile a standalone RISC-V assembly file (start.s) and link it into an ELF file using the RISC-V toolchain. This verifies that the assembler and linker stages work independently of C code.

📁 File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task5/
├── start.s         # Simple RISC-V assembly file
├── start.o         # Assembled object file
├── start.elf       # Final linked ELF file
💻 Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task5

# Step 1: Create your assembly file (if not yet done)
cat << 'EOF' > start.s
.section .text
.global _start
_start:
    li a0, 10
    li a1, 20
    add a2, a0, a1
1:  j 1b
EOF

# Step 2: Assemble to object file
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-as start.s -o start.o

# Step 3: Link into an ELF
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld start.o -o start.elf

# Step 4: Verify ELF sections
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d start.elf | less
📋 Task Checklist Table
Task #	Description	Done?
5.1	Create standalone start.s assembly file	✅
5.2	Assemble to start.o using as	✅
5.3	Link to start.elf using ld	✅
5.4	Verify machine instructions via objdump	✅
5.5	Screenshot of assembly + ELF disassembly	🔲

🖼️ Output Screenshot
📸 Take a screenshot showing successful assembly, linking, and output from:

bash
Copy
Edit
riscv32-unknown-elf-objdump -d start.elf
📘 Explanation
This task proves:

✅ You can write, assemble, and link raw RISC-V assembly

✅ The ELF file structure is correct even without C runtime

✅ Understanding of label _start, registers, and loops

⚙️ Task 6: Combine Assembly and C Code
🎯 Objective
Link an assembly startup file (start.s) with a simple C program (hello.c) to form a working ELF, mimicking how embedded programs boot from assembly and jump into C.

📁 File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task6/
├── start.s         # Assembly file with _start
├── hello.c         # Simple C function (no main needed)
├── start.o         # Object from start.s
├── hello.o         # Object from hello.c
├── start.elf       # Final linked ELF
💻 Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task6

# Step 1: Write hello.c
cat << 'EOF' > hello.c
int my_function() { return 42; }
EOF

# Step 2: Reuse or write start.s
cat << 'EOF' > start.s
.section .text
.global _start
_start:
    call my_function
1:  j 1b
EOF

# Step 3: Compile both
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-as start.s -o start.o

# Step 4: Link them
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld start.o hello.o -o start.elf

# Step 5: Disassemble to confirm function linkage
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d start.elf | less
📋 Task Checklist Table
Task #	Description	Done?
6.1	Create C function (hello.c)	✅
6.2	Call C function from _start in assembly	✅
6.3	Compile both .c and .s to .o files	✅
6.4	Link them to start.elf	✅
6.5	Disassemble to confirm call my_function	✅
6.6	Screenshot with function call disassembly	🔲

🖼️ Output Screenshot
Show a disassembly with the call my_function inside _start, plus the function itself.

📘 Explanation
You’ve built an ELF where:

🧠 Assembly handles boot (simulating reset vector)

🧠 C logic handles logic (like embedded apps do)

🧠 You verified the function call path manually via disassembly

⚙️ Task 7: Inspect and Understand Symbols
🎯 Objective
Use nm and objdump to explore symbols in the ELF — both from C and Assembly — and understand where functions and data reside.

📁 File Structure
bash
Copy
Edit
~/Desktop/vsdflow/task7/
├── hello.c         # Your C code from Task 6
├── start.s         # Assembly file with _start
├── *.o             # Object files
├── start.elf       # Final executable
💻 Working Terminal Commands
bash
Copy
Edit
cd ~/Desktop/vsdflow/task7

# Copy working files from Task 6
cp ~/Desktop/vsdflow/task6/* .

# Rebuild for clean state
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c hello.c -o hello.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-as start.s -o start.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld start.o hello.o -o start.elf

# View symbols
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-nm start.elf
Expected output:

bash
Copy
Edit
00000000 T _start
00000014 T my_function
📋 Task Checklist Table
Task #	Description	Done?
7.1	Use nm to inspect function symbols	✅
7.2	Confirm _start and my_function locations	✅
7.3	Explain sections (T = text, D = data, B = bss)	✅
7.4	Screenshot of nm output	🔲

🖼️ Output Screenshot
Take screenshot of nm start.elf output showing symbols:

r
Copy
Edit
00000000 T _start
00000014 T my_function
📘 Explanation
You now understand:

✅ What symbols are in an ELF file

✅ How to locate your functions (_start, main, etc.)

✅ How code gets organized into sections (.text, .data, .bss)

✅ TASK 8 — Exploring Compiler Optimizations (O0 vs O1 vs O2 vs O3)
✅ Objective:
Compare performance and size differences of the compiled RISC-V code under different GCC optimization flags (-O0, -O1, -O2, -O3) using a loop delay program.

📁 File Setup:
bash
Copy
Edit
cd ~/Desktop/vsdflow && mkdir -p task8 && cd task8
💻 Code: loop_opt.c
c
Copy
Edit
void delay_loop() {
    volatile int i;
    for (i = 0; i < 10000; i++) {
        // Do nothing
    }
}

int main() {
    delay_loop();
    return 0;
}
💻 Build Script: build_all_opts.sh
bash
Copy
Edit
#!/bin/bash
RISCV=/home/amritha-s/vsdflow/riscv/opt/riscv/bin

for opt in 0 1 2 3; do
    echo "=== Building with -O$opt ==="
    $RISCV/riscv32-unknown-elf-gcc -O$opt -o loop_O$opt.elf loop_opt.c
    $RISCV/riscv32-unknown-elf-size loop_O$opt.elf
    echo ""
done
Make executable and run:

bash
Copy
Edit
chmod +x build_all_opts.sh
./build_all_opts.sh
📋 Explanation:
This builds the same file with four optimization levels:

-O0: No optimization (baseline)

-O1: Basic optimization

-O2: Further optimization including loop unrolling

-O3: Aggressive optimization (may inline)

Check how each optimization affects binary size and speed by comparing ELF file size using riscv32-unknown-elf-size.

📸 Screenshot Placeholder:
📸 Screenshot of terminal running ./build_all_opts.sh and showing sizes

📊 Summary Table:
Flag	Optimizes For	Binary Size	Speed (Subjective)
-O0	Debugging, no opt	Largest	Slowest
-O1	Basic perf	Smaller	Faster
-O2	Balance perf/size	Smaller	Fast
-O3	Max speed	May be same	Fastest

✅ TASK 9 — Using objdump to Understand Optimization
✅ Objective:
Disassemble .elf files to compare assembly instructions generated at each optimization level.

💻 Disassemble with objdump
bash
Copy
Edit
for opt in 0 1 2 3; do
    echo "=== Disassembly with -O$opt ==="
    /home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -d loop_O$opt.elf > disasm_O$opt.txt
done
Then inspect each disasm_Ox.txt to compare loop code and check if:

Loop is optimized

Function is inlined

NOPs removed

📋 Explanation:
Using objdump -d, you decode machine code into human-readable assembly to understand compiler behavior.

📸 Screenshot Placeholder:
📸 Screenshot of one of the disassembled .txt files or diff comparison

✅ TASK 10 — Compiling with Debug Info and Analyzing Symbols
✅ Objective:
Use -g flag to include debug info and explore .symtab.

💻 Compile with Debug Info
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -O2 -g -o debug.elf loop_opt.c
💻 View Symbols with nm
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-nm debug.elf
📋 Explanation:
With -g, symbols like main, delay_loop remain visible. Use nm to confirm variable locations, function scope, and linkage.

📸 Screenshot Placeholder:
📸 Screenshot of output from nm debug.elf
### ✅ TASK 11 — Custom Linker Script (minimal.ld)

#### ✅ Objective:
Write a minimal custom linker script to control memory layout. Specifically:
- Place `.text` in Flash memory (0x00000000)
- Place `.data` and `.bss` in SRAM (0x10000000)
- Define `_stack_top` symbol at end of SRAM

---

#### 📁 File Setup:
```bash
cd ~/Desktop/vsdflow/task11
```
Code: minimal.ld
ld
Copy
Edit
ENTRY(_start)

MEMORY {
  FLASH (rx)  : ORIGIN = 0x00000000, LENGTH = 256K
  SRAM  (rwx) : ORIGIN = 0x10000000, LENGTH = 64K
}

SECTIONS {
  .text : {
    *(.text.start)
    *(.text)
    *(.rodata)
  } > FLASH

  .data : {
    _data_start = .;
    *(.data)
    _data_end = .;
  } > SRAM

  .bss : {
    _bss_start = .;
    *(.bss)
    _bss_end = .;
  } > SRAM

  _stack_top = ORIGIN(SRAM) + LENGTH(SRAM);
}
💻 Supporting Files:
test_linker.c

c
Copy
Edit
#include <stdint.h>
uint32_t global_var = 0x12345678;
uint32_t bss_var;
void test_function(void) {
    global_var = 0xABCDEF00;
    bss_var = 0x11111111;
}
void main(void) {
    test_function();
    while (1) {}
}
start.s

asm
Copy
Edit
.section .text.start
.global _start
_start:
  lui sp, %hi(_stack_top)
  addi sp, sp, %lo(_stack_top)
  call main
1: j 1b
.size _start, . - _start
💻 Build All Files in One Go:
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c start.s -o start.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-gcc -c test_linker.c -o test_linker.o
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-ld -T minimal.ld start.o test_linker.o -o test_linker.elf
💻 Inspect ELF Output:
bash
Copy
Edit
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-objdump -h test_linker.elf
/home/amritha-s/vsdflow/riscv/opt/riscv/bin/riscv32-unknown-elf-nm test_linker.elf
📋 Explanation:
.text should start at 0x00000000 (Flash)

.data and .bss go into SRAM

_start entry at 0x00000000

ELF confirms correct memory placement

📸 Screenshot Placeholder:
📸 Screenshot of objdump -h and nm outputs

✅ TASK 12 — LED Blinking with Linker + Disassembly
✅ Objective:
Blink an LED using memory-mapped I/O and compile it with a custom linker script.

📁 File Setup:
bash
Copy
Edit
cd ~/Desktop/vsdflow && rm -rf task12 && mkdir task12 && cd task12
💻 Code: task12_led_blink.c
c
Copy
Edit
#include <stdint.h>
#define GPIO_BASE 0x10012000
#define GPIO_OUTPUT_REG (*(volatile uint32_t *)(GPIO_BASE + 0x00))
#define GPIO_DIRECTION_REG (*(volatile uint32_t *)(GPIO_BASE + 0x04))

void delay(volatile int count) {
    while(count--) { asm volatile("nop"); }
}

int main(void) {
    GPIO_DIRECTION_REG |= 0x1;
    while (1) {
        GPIO_OUTPUT_REG ^= 0x1;
        delay(100000);
    }
    return 0;
}
led_start.s

asm
Copy
Edit
.section .text.start
.global _start
_start:
    lui sp, %hi(_stack_top)
    addi sp, sp, %lo(_stack_top)
    call main
1:  j 1b
led_blink.ld

ld
Copy
Edit
ENTRY(_start)

MEMORY {
  FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 256K
  SRAM  (rwx): ORIGIN = 0x10000000, LENGTH = 64K
}

SECTIONS {
  .text : {
    *(.text.start)
    *(.text)
    *(.rodata*)
  } > FLASH

  .data : {
    _data_start = .;
    *(.data)
    _data_end = .;
  } > SRAM

  .bss : {
    _bss_start = .;
    *(.bss)
    _bss_end = .;
  } > SRAM

  _stack_top = ORIGIN(SRAM) + LENGTH(SRAM);
}
💻 Build Script: build_led_blink.sh
bash
Copy
Edit
#!/bin/bash
RISCV=/home/amritha-s/vsdflow/riscv/opt/riscv/bin

echo "=== Building LED Blink ==="
$RISCV/riscv32-unknown-elf-gcc -c led_start.s -o led_start.o
$RISCV/riscv32-unknown-elf-gcc -c task12_led_blink.c -o task12_led_blink.o
$RISCV/riscv32-unknown-elf-ld -T led_blink.ld led_start.o task12_led_blink.o -o task12_led_blink.elf

echo "=== ELF Sections ==="
$RISCV/riscv32-unknown-elf-objdump -h task12_led_blink.elf

echo "=== Disassembly ==="
$RISCV/riscv32-unknown-elf-objdump -d task12_led_blink.elf | less
bash
Copy
Edit
chmod +x build_led_blink.sh
./build_led_blink.sh
📋 Explanation:
GPIO is toggled using memory-mapped I/O

Delay uses software nop loop

Custom linker places code and variables properly

Objdump output confirms working ELF

📸 Screenshot Placeholder:
📸 Screenshot of blinking logic disassembly or ELF sections
### ✅ TASK 13 — Interrupt Primer (MTIP Handler)

#### ✅ Objective:
Enable the machine-timer interrupt (MTIP) and write a simple handler in C/assembly.

---

#### 🛠️ Files & Line-up

`timer_interrupt.c`
```c
#define UART_TX 0x10000000
#define UART_READY 0x10000005
#define MTIME 0x0200BFF8
#define MTIMECMP 0x02004000
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

void uart_putc(char c) {
    volatile char* tx = (volatile char*)UART_TX;
    volatile char* rd = (volatile char*)UART_READY;
    while (!(*rd & (1 << 5)));
    *tx = c;
}

void uart_puts(const char* s) {
    while (*s) uart_putc(*s++);
}

void timer_handler(void) {
    uart_puts("MTIP\n");
    volatile uint64_t* mtime = (volatile uint64_t*)MTIME;
    volatile uint64_t* mtimecmp = (volatile uint64_t*)MTIMECMP;
    *mtimecmp = *mtime + 1000000;
}

void enable_timer_interrupt(void) {
    volatile uint64_t* mtime = (volatile uint64_t*)MTIME;
    volatile uint64_t* mtimecmp = (volatile uint64_t*)MTIMECMP;
    *mtimecmp = *mtime + 1000000;
    asm volatile("li t0, 0x80");
    asm volatile("csrs mie, t0");
    asm volatile("csrs mstatus, 0x8");
}

int main() {
    uart_putc('A');
    enable_timer_interrupt();
    uart_puts("Timer enabled\n");
    while (1) {
        uart_putc('.');
        for (volatile int i = 0; i < 100000; i++);
    }
    return 0;
}
```
trap_handler.s

asm
Copy
Edit
.section .text
.global trap_handler
.align 4
trap_handler:
    addi sp, sp, -64
    sw ra, 0(sp)
    sw t0, 4(sp)
    sw t1, 8(sp)
    csrr t0, mcause
    li t1, 0x80000007
    bne t0, t1, skip
    jal timer_handler
skip:
    lw ra, 0(sp)
    lw t0, 4(sp)
    lw t1, 8(sp)
    addi sp, sp, 64
    mret
startup13.s

asm
Copy
Edit
.section .text.start
.global _start
_start:
    la sp, _stack_top
    li t0, 0x10000005
    li t1, 0x20
wait_uart:
    lb t2, 0(t0)
    and t2, t2, t1
    beq t2, zero, wait_uart
    li t0, 0x10000000
    li t1, 'S'
    sb t1, 0(t0)
    la t0, trap_handler
    csrw mtvec, t0
    jal main
    j .
.section .bss
.align 4
.space 1024
_stack_top:
linker13.ld

ld
Copy
Edit
OUTPUT_ARCH(riscv)
ENTRY(_start)
MEMORY {
  FLASH (rx) : ORIGIN = 0x80000000, LENGTH = 16M
  RAM   (rw) : ORIGIN = 0x81000000, LENGTH = 16M
}
SECTIONS {
  .text : { *(.text.start) *(.text*) } > FLASH
  .rodata : ALIGN(4) { *(.rodata*) } > FLASH
  .data : ALIGN(4) { *(.data*) } > RAM AT > FLASH
  .bss   : ALIGN(4) { *(.bss*) } > RAM
  _end = .;
}
💻 Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -g -O0 -march=rv32im -mabi=ilp32 -nostdlib \
  -T linker13.ld \
  -o timer.elf \
  timer_interrupt.c startup13.s trap_handler.s

qemu-system-riscv32 -nographic -machine virt -bios none -kernel timer.elf
📋 Expected Output:
nginx
Copy
Edit
SATimer enabled
........MTIP
MTIP
MTIP
MTIP
🐞 Issues Faced:
Incorrect CSR writes to mie and mstatus: fixed ordering.

Confirmed MTIP fires correctly.

📸 Screenshot Placeholder:
📸 Screenshot of UART output showing periodic "MTIP"

✅ TASK 14 — RV32IMAC vs RV32IMC (“A” Extension)
✅ Objective:
Compare RV32IMC vs RV32IMAC, focusing on atomic instructions.

🛠️ Summary Table
Feature	RV32IMC	RV32IMAC
I (Base Int)	✅	✅
M (Mul/Div)	✅	✅
C (Compressed)	✅	✅
A (Atomic)	❌	✅

🔸 Atomic Instruction Set
Instruction	Meaning	Use Case
lr.w	Load-Reserved	Begin RMW atomic op
sc.w	Store-Conditional	Complete atomic store
amoadd.w	Atomic Add	Atomic update of counter
amoswap.w	Atomic Swap	Exchange value atomically
amoor.w	Atomic OR	Set flags atomically
amoand.w	Atomic AND	Clear flags atomically
amomin.w	Atomic Min	Resource arbitration
amomax.w	Atomic Max	Tracking max safely

✅ Status: Completed
📸 Screenshot Placeholder:
📸 Diagram/table comparing RV32IMC vs RV32IMAC and listing atomic instructions

✅ TASK 15 — Atomic Test Program (lr.w/sc.w Mutex)
✅ Objective:
Implement a spin-lock mutex using lr.w / sc.w, simulate two “threads”.

🛠️ Code Files
task15.c (Full code in previous message)

Linker15.ld (As above)

startup15.s (As above)

💻 Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -g -O0 -march=rv32imac -mabi=ilp32 -nostdlib \
  -T Linker15.ld \
  -o task15.elf \
  task15.c startup15.s

qemu-system-riscv32 -nographic -machine virt -bios none -kernel task15.elf
💬 Expected Output:
makefile
Copy
Edit
SAStarting threads
T1: Enter critical section
T1: Counter = 1
...
Done
........
🐞 Issues Faced:
Initial infinite loop due to improper sc.w retry logic.

Fixed by ensuring sc.w return checked, with correct CVS stubs.

📸 Screenshot Placeholder:
📸 Snapshot showing interleaved thread output and mutex working

✅ TASK 16 — Newlib printf on Bare-Metal
✅ Objective:
Retarget _write() for printf() to memory-mapped UART in bare-metal environment.

🛠️ Code Files
Task16.c (Includes _write, _sbrk, etc.)

startup16.s, linker16.ld (As above)

💻 Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 \
  -c startup16.s task16.c

riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 -nostartfiles \
  -T linker16.ld \
  -o task16.elf startup16.o task16.o

qemu-system-riscv32 -nographic -machine virt -bios none -kernel task16.elf
💬 Expected Output:
yaml
Copy
Edit
SAHello, RISC-V! Counter: 42
........
🐞 Issues Faced:
printf silent until adding _fstat(), _isatty(), _sbrk().

Needed correct errno handling and heap limit.

📸 Screenshot Placeholder:
📸 Console showing "Hello, RISC‑V! Counter: 42" and running dots

✅ TASK 17 — Endianness & Struct Packing Check
✅ Objective:
Verify RV32 endianness with union trick and print byte order via UART.

🛠️ Code Files
task17.c, startup17.s, linker17.ld (As above)

💻 Commands
bash
Copy
Edit
riscv32-unknown-elf-gcc -c task17.c -march=rv32imac -mabi=ilp32 -Os
riscv32-unknown-elf-gcc -c startup17.s -march=rv32imac -mabi=ilp32
riscv32-unknown-elf-gcc startup17.o task17.o -march=rv32imac -mabi=ilp32 \
  -nostartfiles -T linker17.ld -o task17.elf

qemu-system-riscv32 -nographic -machine virt -bios none -kernel task17.elf
💬 Expected Output:
yaml
Copy
Edit
Bare‑metal RISC‑V Application
Value of x: 43
Verifying Byte Ordering (Endianness):
Value stored: 0x01020304
Bytes in memory:
Byte 0: 0x04
...
This system is Little‑Endian.
🐞 Issues Faced:
Required explicit \n to make output readable.

Used volatile to ensure union not optimized away.

📸 Screenshot Placeholder:
